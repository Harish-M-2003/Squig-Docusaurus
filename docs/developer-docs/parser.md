---
sidebar_label : "Parser"
sidebar_position : 4
---
# Parser

The Parser class in Squig is responsible for parsing the source code based on the defined grammar rules. It analyzes the sequence of tokens generated by the Lexer and constructs a syntax tree representing the structure of the Squig program.

## Parser Class

The Parser class defines methods to parse different components of Squig code according to the specified grammar rules. These methods recursively traverse the token sequence and apply parsing rules to identify and construct syntactic elements such as expressions, statements, and declarations.

### Grammar Rules:

The Squig grammar consists of various rules for defining expressions, statements, and other language constructs. These rules govern the syntax of Squig code and guide the parsing process performed by the Parser class.

- **Statements**: Represented by the `statements` rule, which defines the structure of statements in Squig programs.
- **Expressions**: Defined by the `expression` rule, which specifies the syntax for expressions in Squig code.
- **Relational Expressions**: Governed by the `relational-expression` rule, which handles relational operators and expressions.
- **Arithmetic Expressions**: Described by the `arithmetic-expression` rule, which deals with arithmetic operations and expressions.
- **Terms and Factors**: Governed by the `term` and `factor` rules, which define the structure of arithmetic terms and factors.
- **Power Expressions**: Defined by the `power` rule, which handles power operations and expressions.
- **Calls and Atoms**: Represented by the `call` and `atom` rules, which define function calls and atomic expressions.
- **Variables and Collections**: Governed by the `variable` and `collection-statement` rules, which handle variables and collections.
- **Control Flow Statements**: Described by rules such as `if-statement`, `for-loop-statement`, `function-statement`, `file-statement`, and `switch-statement`, which define various control flow constructs in Squig code.

### Methods:

- **`statement(self)`**: Parses a single statement in the Squig program.
- **`expression(self)`**: Parses an expression according to the grammar rules.
- **`relational_expression(self)`**: Parses a relational expression, handling relational operators.
- **`arithmetic_expression(self)`**: Parses an arithmetic expression, handling arithmetic operations.
- **`term(self)`**: Parses a term in an arithmetic expression.
- **`factor(self)`**: Parses a factor in an arithmetic expression.
- **`power(self)`**: Parses a power expression, handling exponentiation.
- **`call(self)`**: Parses a function call expression.
- **`atom(self)`**: Parses an atomic expression.
- **`variable(self)`**: Parses a variable or variable expression.
- **`collection_statement(self)`**: Parses a collection statement.
- **`if_statement(self)`**: Parses an if statement.
- **`for_loop_statement(self)`**: Parses a for loop statement.
- **`function_statement(self)`**: Parses a function statement.
- **`file_statement(self)`**: Parses a file statement.
- **`switch_statement(self)`**: Parses a switch statement.

### Code Explanation:

The provided code defines the Parser class and its methods for parsing different components of Squig code. Each method implements parsing logic according to the specified grammar rules, recursively traversing the token sequence and constructing syntax trees.

### Example Usage:

```python
from Parser import Parser

# Initialize Parser with token sequence
parser = Parser(tokens)

# Parse the Squig code
syntax_tree, error = parser.parse()

if error:
    print("Error:", error)
else:
    # Execute or analyze the syntax tree
    ...
```

## Conclusion

The Parser class in Squig plays a crucial role in the compilation process by interpreting the structure of Squig code according to predefined grammar rules. By accurately parsing Squig programs, the Parser enables subsequent phases of compilation, such as interpretation or code generation, ensuring correct execution of Squig programs.
